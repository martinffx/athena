{
  "project": "cli_subcommands",
  "architecture": "single_file_go_with_tdd",
  "task_categories": {
    "foundation": {
      "description": "Core infrastructure and dependency setup",
      "order": 1
    },
    "entities": {
      "description": "Domain entities with business logic and validation",
      "order": 2
    },
    "services": {
      "description": "Business services with platform-specific implementations",
      "order": 3
    },
    "cli": {
      "description": "CLI command interface and routing",
      "order": 4
    },
    "integration": {
      "description": "System integration and backward compatibility",
      "order": 5
    }
  },
  "tasks": [
    {
      "id": "F001",
      "category": "foundation",
      "name": "Add Cobra CLI Framework Dependency",
      "description": "Integrate github.com/spf13/cobra for command routing while maintaining single-file architecture",
      "dependencies": [],
      "deliverables": [
        "go.mod updated with cobra dependency",
        "Basic cobra command structure in main.go",
        "Legacy mode detection function",
        "Command routing stub functions"
      ],
      "effort_hours": 2,
      "testing_requirements": [
        "Test cobra integration doesn't break existing functionality",
        "Test legacy mode detection with various argument patterns",
        "Test command routing stub works correctly"
      ],
      "platform_considerations": "Cross-platform compatible, no OS-specific code",
      "implementation_notes": "Add cobra imports and basic command structure to main.go, maintain single-file architecture"
    },
    {
      "id": "F002", 
      "category": "foundation",
      "name": "Create Data Directory Structure Utilities",
      "description": "Implement cross-platform data directory creation and management (~/.openrouter-cc/)",
      "dependencies": [],
      "deliverables": [
        "ensureDataDir() function with proper permissions",
        "getDataDir() function with platform-specific paths",
        "Directory permission constants for Unix/Windows",
        "Error handling for permission/access issues"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test directory creation with various permission scenarios",
        "Test directory access validation",
        "Test cross-platform path resolution",
        "Test error handling for insufficient permissions"
      ],
      "platform_considerations": {
        "unix": "0755 directory permissions, respect umask",
        "windows": "Use appropriate ACLs and directory attributes"
      },
      "implementation_notes": "Use os.UserHomeDir() for cross-platform home directory detection"
    },
    {
      "id": "E001",
      "category": "entities", 
      "name": "ProcessEntity - Core Structure and Validation",
      "description": "Implement ProcessEntity struct with validation methods and business rules",
      "dependencies": ["F002"],
      "deliverables": [
        "ProcessEntity struct with fields (pid, port, startTime, configPath)",
        "Validate() method with business rule validation",
        "JSON serialization/deserialization support",
        "Unit tests covering all validation scenarios"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test validation rules for PID, port, startTime, configPath",
        "Test JSON serialization round-trip",
        "Test validation with edge cases (negative PID, invalid ports)",
        "Test validation with missing or inaccessible config files"
      ],
      "platform_considerations": "PID validation needs to be cross-platform compatible",
      "implementation_notes": "Use json struct tags for serialization, implement comprehensive validation logic"
    },
    {
      "id": "E002",
      "category": "entities",
      "name": "ProcessEntity - Process Existence Detection",
      "description": "Implement IsAlive() method with cross-platform process detection",
      "dependencies": ["E001"],
      "deliverables": [
        "IsAlive() method with platform-specific implementations", 
        "Process detection utilities (Unix: kill signal 0, Windows: OpenProcess)",
        "Error handling for process access permissions",
        "Unit tests with mock processes and edge cases"
      ],
      "effort_hours": 5,
      "testing_requirements": [
        "Test IsAlive() with current process (should return true)",
        "Test IsAlive() with non-existent PID (should return false)",
        "Test IsAlive() with permission denied scenarios",
        "Test cross-platform process detection logic"
      ],
      "platform_considerations": {
        "unix": "Use kill(pid, 0) syscall for process existence check",
        "windows": "Use OpenProcess API with PROCESS_QUERY_INFORMATION"
      },
      "implementation_notes": "Use build tags or runtime.GOOS for platform-specific implementations"
    },
    {
      "id": "E003",
      "category": "entities",
      "name": "ProcessEntity - File Persistence Methods",
      "description": "Implement FromPidFile() and ToPidFile() methods with atomic file operations",
      "dependencies": ["E002"],
      "deliverables": [
        "FromPidFile() method with JSON deserialization and validation",
        "ToPidFile() method with atomic write operations",
        "File locking utilities for atomic operations",
        "Error handling for corrupt or missing PID files"
      ],
      "effort_hours": 6,
      "testing_requirements": [
        "Test successful read/write operations",
        "Test handling of corrupt JSON files",
        "Test handling of missing PID files",
        "Test atomic write operations don't leave partial files",
        "Test file locking prevents concurrent access"
      ],
      "platform_considerations": {
        "unix": "Use flock syscall for exclusive file locking",
        "windows": "Use file attributes with sharing restrictions"
      },
      "implementation_notes": "Implement atomic write pattern: write to temp file, then rename. Use defer for cleanup."
    },
    {
      "id": "E004",
      "category": "entities",
      "name": "StateEntity - File Management Structure",
      "description": "Implement StateEntity struct with file path management and validation",
      "dependencies": ["F002"],
      "deliverables": [
        "StateEntity struct with file path fields",
        "Constructor with default path resolution",
        "Path validation and accessibility checks",
        "Unit tests for path resolution and validation"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test default path resolution across platforms",
        "Test path validation with various scenarios",
        "Test accessibility checks for read/write permissions",
        "Test handling of non-existent parent directories"
      ],
      "platform_considerations": "Use filepath.Join for cross-platform path construction",
      "implementation_notes": "Use path/filepath package for reliable cross-platform path handling"
    },
    {
      "id": "E005",
      "category": "entities",
      "name": "StateEntity - Directory and File Operations",
      "description": "Implement EnsureDataDir(), LockPidFile(), and file management methods",
      "dependencies": ["E004"],
      "deliverables": [
        "EnsureDataDir() method with proper permissions",
        "LockPidFile() method with exclusive locking", 
        "File operation utilities with error handling",
        "Cleanup methods for temporary files"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test directory creation with various permission scenarios",
        "Test file locking mechanisms across platforms",
        "Test cleanup operations remove temporary files",
        "Test error handling for permission denied scenarios"
      ],
      "platform_considerations": {
        "unix": "Use appropriate file permissions (0755 for dirs, 0600 for sensitive files)",
        "windows": "Handle Windows-specific file attributes and ACLs"
      },
      "implementation_notes": "Implement platform-specific file locking with build tags"
    },
    {
      "id": "E006",
      "category": "entities",
      "name": "StateEntity - Log Rotation Management",
      "description": "Implement RotateLogs() method with size-based rotation and retention",
      "dependencies": ["E005"],
      "deliverables": [
        "RotateLogs() method with 10MB size threshold",
        "Log file retention logic (keep 3 files)",
        "Atomic log rotation to prevent data loss",
        "Log size monitoring utilities"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test log rotation when size threshold exceeded",
        "Test log file retention (keeps exactly 3 files)",
        "Test atomic rotation doesn't lose log data",
        "Test rotation with concurrent write operations"
      ],
      "platform_considerations": "Atomic file operations must work across all platforms",
      "implementation_notes": "Use atomic rename operations for log rotation. Handle concurrent writes safely."
    },
    {
      "id": "S001",
      "category": "services",
      "name": "StateManager - Basic File Operations Service",
      "description": "Implement StateManager service with basic save/load operations",
      "dependencies": ["E003", "E006"],
      "deliverables": [
        "StateManager struct with configuration",
        "SaveProcessState() method with atomic writes",
        "LoadProcessState() method with validation",
        "Error handling for file operations"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test successful save and load operations",
        "Test load operation validates process still exists",
        "Test error handling for corrupt files",
        "Test concurrent access scenarios"
      ],
      "platform_considerations": "File operations must be atomic across all platforms",
      "implementation_notes": "Use ProcessEntity and StateEntity methods, add orchestration logic"
    },
    {
      "id": "S002",
      "category": "services",
      "name": "StateManager - Cleanup and Maintenance Operations",
      "description": "Implement CleanupFiles() and maintenance operations for StateManager",
      "dependencies": ["S001"],
      "deliverables": [
        "CleanupFiles() method to remove stale files",
        "Maintenance operations for log rotation",
        "Garbage collection for temporary files",
        "Health check operations for state consistency"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test cleanup removes only stale/invalid files",
        "Test cleanup preserves active process state",
        "Test maintenance operations don't interfere with running processes",
        "Test garbage collection handles edge cases"
      ],
      "platform_considerations": "File cleanup operations must handle platform-specific file locking",
      "implementation_notes": "Ensure cleanup operations are safe and don't interfere with running daemons"
    },
    {
      "id": "S003",
      "category": "services",
      "name": "ProcessManager - Core Structure and Configuration",
      "description": "Implement ProcessManager service structure with configuration management",
      "dependencies": ["S002"],
      "deliverables": [
        "ProcessManager struct with dependencies",
        "Constructor with configuration validation",
        "Configuration management for daemon settings",
        "Basic error handling and logging setup"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test ProcessManager initialization with valid configs",
        "Test configuration validation catches invalid settings",
        "Test dependency injection works correctly",
        "Test error handling provides useful feedback"
      ],
      "platform_considerations": "Configuration should be platform-agnostic where possible",
      "implementation_notes": "Integrate with existing Config struct, add daemon-specific settings"
    },
    {
      "id": "S004",
      "category": "services",
      "name": "ProcessManager - Daemon Status Operations",
      "description": "Implement GetStatus() and IsRunning() methods for process monitoring",
      "dependencies": ["S003"],
      "deliverables": [
        "GetStatus() method returning comprehensive process status",
        "IsRunning() method for quick status checks",
        "ProcessStatus struct with detailed information",
        "Process health monitoring utilities"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test status retrieval for running processes",
        "Test status retrieval for stopped processes",
        "Test status retrieval with stale PID files",
        "Test health monitoring detects process issues"
      ],
      "platform_considerations": "Process monitoring APIs differ between Unix and Windows",
      "implementation_notes": "Return structured status information including uptime, memory usage, etc."
    },
    {
      "id": "S005",
      "category": "services",
      "name": "ProcessManager - Daemon Start Operations",
      "description": "Implement StartDaemon() method with cross-platform process creation",
      "dependencies": ["S004"],
      "deliverables": [
        "StartDaemon() method with process creation",
        "Cross-platform daemon spawning logic", 
        "Process group and session management",
        "I/O redirection to log files"
      ],
      "effort_hours": 6,
      "testing_requirements": [
        "Test daemon starts successfully and detaches",
        "Test daemon process has correct process group",
        "Test I/O redirection works correctly",
        "Test multiple start attempts are handled properly",
        "Test daemon starts with clean environment"
      ],
      "platform_considerations": {
        "unix": "Use setpgid for process group, handle signals properly",
        "windows": "Use CREATE_NEW_PROCESS_GROUP flag, handle Windows-specific process creation"
      },
      "implementation_notes": "Extract existing server creation logic to reusable function for daemon mode"
    },
    {
      "id": "S006",
      "category": "services",
      "name": "ProcessManager - Daemon Stop Operations",
      "description": "Implement StopDaemon() method with graceful shutdown and timeout handling",
      "dependencies": ["S005"],
      "deliverables": [
        "StopDaemon() method with graceful shutdown",
        "Signal handling for clean termination",
        "Timeout handling with force termination fallback",
        "Process cleanup and state file removal"
      ],
      "effort_hours": 5,
      "testing_requirements": [
        "Test graceful shutdown with SIGTERM/Interrupt",
        "Test timeout handling triggers force termination",
        "Test cleanup operations complete successfully",
        "Test stop operation is idempotent",
        "Test force termination as last resort"
      ],
      "platform_considerations": {
        "unix": "Use SIGTERM then SIGKILL for graceful shutdown",
        "windows": "Use os.Interrupt then TerminateProcess"
      },
      "implementation_notes": "Implement timeout-based graceful shutdown with force termination fallback"
    },
    {
      "id": "C001",
      "category": "cli",
      "name": "CLI Command Structure Setup",
      "description": "Set up cobra command structure and root command configuration",
      "dependencies": ["F001"],
      "deliverables": [
        "Root command configuration with cobra",
        "Command hierarchy setup (start, stop, status, logs, code)",
        "Global flag definitions for backward compatibility",
        "Help text and usage documentation"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test root command initializes correctly",
        "Test all subcommands are registered",
        "Test help text displays correctly",
        "Test global flags are accessible to subcommands"
      ],
      "platform_considerations": "CLI behavior should be consistent across platforms",
      "implementation_notes": "Configure cobra commands within main.go, maintain single-file architecture"
    },
    {
      "id": "C002", 
      "category": "cli",
      "name": "Legacy Mode Detection and Routing",
      "description": "Implement backward compatibility detection and routing logic",
      "dependencies": ["C001"],
      "deliverables": [
        "isLegacyMode() function to detect old usage patterns",
        "Legacy command handler preserving existing behavior", 
        "Routing logic to choose between legacy and new modes",
        "Comprehensive tests for all legacy flag combinations"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test legacy mode detection with no arguments",
        "Test legacy mode detection with flag arguments",
        "Test legacy mode preserves exact existing behavior",
        "Test new mode routing works for valid subcommands"
      ],
      "platform_considerations": "Legacy mode behavior must be identical across platforms",
      "implementation_notes": "Preserve 100% backward compatibility - existing usage should work exactly as before"
    },
    {
      "id": "C003",
      "category": "cli",
      "name": "Start Command Implementation",
      "description": "Implement 'openrouter-cc start' command with daemon creation",
      "dependencies": ["C002", "S006"],
      "deliverables": [
        "Start command handler with validation",
        "Port availability checking",
        "Configuration validation and loading",
        "Success/failure feedback with progress indicators"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test start command with valid configuration",
        "Test start command with port conflicts",
        "Test start command with invalid configuration",
        "Test start command provides clear feedback",
        "Test start command handles existing daemon gracefully"
      ],
      "platform_considerations": "Port checking and daemon creation must work cross-platform",
      "implementation_notes": "Integrate with ProcessManager service, provide user-friendly feedback"
    },
    {
      "id": "C004",
      "category": "cli",
      "name": "Stop Command Implementation", 
      "description": "Implement 'openrouter-cc stop' command with graceful shutdown",
      "dependencies": ["C003"],
      "deliverables": [
        "Stop command handler with confirmation prompts",
        "Graceful shutdown with timeout configuration",
        "Force stop option for unresponsive daemons",
        "Clear feedback on shutdown progress and result"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test stop command with running daemon",
        "Test stop command with no running daemon",
        "Test stop command with force flag",
        "Test stop command timeout handling",
        "Test user confirmation prompts work correctly"
      ],
      "platform_considerations": "Signal handling must work correctly on all platforms",
      "implementation_notes": "Integrate with ProcessManager.StopDaemon(), add user interaction"
    },
    {
      "id": "C005",
      "category": "cli",
      "name": "Status Command Implementation",
      "description": "Implement 'openrouter-cc status' command with detailed process information",
      "dependencies": ["C004"],
      "deliverables": [
        "Status command handler with formatted output",
        "JSON output option for programmatic use",
        "Verbose mode with detailed process information",
        "Health check integration and reporting"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test status command with running daemon",
        "Test status command with stopped daemon",
        "Test JSON output format is valid and complete",
        "Test verbose mode provides additional detail",
        "Test status command handles stale PID files"
      ],
      "platform_considerations": "Process information gathering varies by platform",
      "implementation_notes": "Format output nicely for human reading, ensure JSON output is machine-parseable"
    },
    {
      "id": "C006",
      "category": "cli",
      "name": "Logs Command Implementation",
      "description": "Implement 'openrouter-cc logs' command with log viewing and following",
      "dependencies": ["C005"],
      "deliverables": [
        "Logs command handler with file reading",
        "Follow mode for real-time log monitoring (-f flag)",
        "Log filtering and search capabilities",
        "Proper handling of log rotation"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test logs command displays recent log entries",
        "Test follow mode streams new log entries",
        "Test logs command handles missing log files gracefully",
        "Test logs command works with rotated log files",
        "Test log filtering and search functionality"
      ],
      "platform_considerations": "File watching/following mechanisms vary by platform",
      "implementation_notes": "Implement log following with proper file watching, handle log rotation gracefully"
    },
    {
      "id": "C007",
      "category": "cli",
      "name": "Code Command Implementation",
      "description": "Implement 'openrouter-cc code' command that starts daemon and launches Claude Code",
      "dependencies": ["C006"],
      "deliverables": [
        "Code command handler that starts daemon if needed",
        "Claude Code process launching with proper arguments",
        "Environment variable setup for Claude Code integration",
        "Error handling for Claude Code launch failures"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test code command starts daemon if not running",
        "Test code command uses existing daemon if available",
        "Test code command launches Claude Code with correct arguments",
        "Test code command handles Claude Code launch failures gracefully",
        "Test code command passes environment variables correctly"
      ],
      "platform_considerations": {
        "unix": "Use exec to launch Claude Code",
        "windows": "Use cmd.exe or PowerShell to launch Claude Code"
      },
      "implementation_notes": "Coordinate with ProcessManager to ensure daemon is running before launching Claude Code"
    },
    {
      "id": "I001",
      "category": "integration",
      "name": "Server Creation Logic Extraction",
      "description": "Extract existing HTTP server creation logic to reusable function for daemon mode",
      "dependencies": ["S006"],
      "deliverables": [
        "createServer() function extracted from main()",
        "startServer() function for both daemon and direct modes",
        "Configuration parameter passing for server creation",
        "Refactored main() function to use extracted logic"
      ],
      "effort_hours": 3,
      "testing_requirements": [
        "Test extracted server creation works identically to original",
        "Test server creation works in daemon mode",
        "Test server creation works in legacy mode",
        "Test configuration passing preserves all existing behavior"
      ],
      "platform_considerations": "Server creation behavior must be identical across all modes",
      "implementation_notes": "Carefully extract without changing behavior, ensure daemon and direct modes work identically"
    },
    {
      "id": "I002",
      "category": "integration",
      "name": "Enhanced Configuration Management",
      "description": "Enhance existing config system with daemon-specific settings and validation",
      "dependencies": ["I001"],
      "deliverables": [
        "Enhanced Config struct with daemon settings",
        "Configuration validation for daemon-specific options",
        "Configuration display methods for status command",
        "Backward compatibility for all existing config options"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test enhanced config preserves all existing functionality",
        "Test daemon-specific config options work correctly",
        "Test config validation catches invalid daemon settings",
        "Test config display methods format output correctly"
      ],
      "platform_considerations": "Configuration file handling must work across all platforms",
      "implementation_notes": "Extend existing Config struct carefully, preserve all current behavior"
    },
    {
      "id": "I003",
      "category": "integration",
      "name": "Enhanced Logging with File Output",
      "description": "Enhance logging system to support file output for daemon mode with rotation",
      "dependencies": ["I002"],
      "deliverables": [
        "Enhanced logging with file output capability",
        "Log rotation integration with StateEntity",
        "Proper log formatting for both console and file output",
        "Log level configuration and management"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test file logging works correctly in daemon mode",
        "Test console logging preserved in legacy mode", 
        "Test log rotation works with concurrent writes",
        "Test log formatting is consistent and readable"
      ],
      "platform_considerations": "File logging and rotation must work on all platforms",
      "implementation_notes": "Enhance existing logging without breaking current console output behavior"
    },
    {
      "id": "I004",
      "category": "integration",
      "name": "Signal Handling and Graceful Shutdown",
      "description": "Implement proper signal handling for graceful daemon shutdown across platforms",
      "dependencies": ["I003"],
      "deliverables": [
        "Cross-platform signal handling for graceful shutdown",
        "Cleanup operations on shutdown (remove PID files, etc.)",
        "Timeout handling for shutdown operations",
        "Integration with existing HTTP server shutdown logic"
      ],
      "effort_hours": 5,
      "testing_requirements": [
        "Test graceful shutdown responds to appropriate signals",
        "Test cleanup operations complete during shutdown",
        "Test timeout handling prevents hanging processes",
        "Test signal handling works correctly on all platforms"
      ],
      "platform_considerations": {
        "unix": "Handle SIGTERM, SIGINT signals appropriately",
        "windows": "Handle Ctrl+C and system shutdown signals"
      },
      "implementation_notes": "Integrate with existing shutdown logic, ensure daemon processes shutdown cleanly"
    },
    {
      "id": "I005",
      "category": "integration",
      "name": "Main Function Refactoring",
      "description": "Refactor main() function to serve as command dispatcher while preserving backward compatibility",
      "dependencies": ["I004", "C007"],
      "deliverables": [
        "Refactored main() function as command dispatcher",
        "Preserved legacy mode behavior exactly as before",
        "Clean integration of cobra command handling",
        "Proper error handling and exit codes"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Test main() function routes commands correctly",
        "Test legacy mode works exactly as before refactoring",
        "Test all new subcommands work through main() dispatcher",
        "Test error handling and exit codes are appropriate"
      ],
      "platform_considerations": "Command dispatching must work identically across platforms",
      "implementation_notes": "This is the final integration step - ensure all components work together seamlessly"
    },
    {
      "id": "T001",
      "category": "integration",
      "name": "Comprehensive Integration Testing",
      "description": "Create comprehensive integration tests covering all command workflows and edge cases",
      "dependencies": ["I005"],
      "deliverables": [
        "End-to-end workflow tests (start → status → stop)",
        "Backward compatibility test suite", 
        "Error scenario testing (port conflicts, permissions, etc.)",
        "Cross-platform integration validation"
      ],
      "effort_hours": 6,
      "testing_requirements": [
        "Test all command workflows work end-to-end",
        "Test backward compatibility with extensive flag combinations",
        "Test error scenarios are handled gracefully",
        "Test cross-platform compatibility thoroughly"
      ],
      "platform_considerations": "Integration tests must pass on Linux, macOS, and Windows",
      "implementation_notes": "Use table-driven tests and temporary directories for isolated test runs"
    },
    {
      "id": "T002",
      "category": "integration", 
      "name": "Performance and Load Testing",
      "description": "Validate performance targets and resource usage under load",
      "dependencies": ["T001"],
      "deliverables": [
        "Performance benchmarks for all commands",
        "Memory usage validation for daemon operations",
        "Load testing for concurrent operations",
        "Resource cleanup validation under stress"
      ],
      "effort_hours": 4,
      "testing_requirements": [
        "Verify command response times meet targets (<100ms)",
        "Verify daemon startup time meets target (<2s)",
        "Verify memory overhead meets target (<500KB)",
        "Verify resource cleanup works under stress conditions"
      ],
      "platform_considerations": "Performance characteristics may vary by platform",
      "implementation_notes": "Use Go benchmarking tools and resource monitoring for validation"
    }
  ],
  "task_dependencies": {
    "parallel_opportunities": [
      "F001 and F002 can be done in parallel",
      "E001 and E004 can be done in parallel after F002",
      "E002 and E005 can be done in parallel",
      "C001 through C007 can have some parallelization after dependencies met",
      "All testing tasks build on integration completion"
    ],
    "critical_path": [
      "F002 → E001 → E002 → E003 → S001 → S002 → S003 → S004 → S005 → S006 → I001 → I002 → I003 → I004 → I005"
    ],
    "estimated_total_effort": {
      "foundation": 5,
      "entities": 23,
      "services": 19,
      "cli": 25,
      "integration": 30,
      "total_hours": 102
    }
  },
  "quality_gates": {
    "per_task": [
      "All unit tests pass with >90% coverage",
      "Code follows existing style conventions", 
      "TDD workflow followed (test first, then implementation)",
      "Error handling includes appropriate user feedback",
      "Platform-specific code properly isolated with build tags"
    ],
    "integration": [
      "100% backward compatibility verified",
      "All new commands work across Linux, macOS, Windows",
      "Performance targets met on all platforms",
      "Security review passes for file operations",
      "Documentation updated and accurate"
    ]
  },
  "risk_mitigation": {
    "single_file_architecture": "Maintain careful organization within main.go using clear section comments and logical grouping",
    "cross_platform_compatibility": "Use build tags for platform-specific code, extensive testing on all platforms",
    "backward_compatibility": "Comprehensive testing of existing flag combinations and usage patterns",
    "file_operations": "Implement atomic operations with proper locking and error recovery",
    "process_management": "Platform-specific testing and graceful degradation for edge cases"
  },
  "success_criteria": {
    "functionality": [
      "All existing CLI usage works exactly as before",
      "All new subcommands work reliably across platforms",
      "Daemon lifecycle management works correctly",
      "State persistence survives system operations"
    ],
    "performance": [
      "Command response time <100ms (95th percentile)",
      "Daemon startup time <2 seconds",  
      "Memory overhead <500KB",
      "No regression in proxy performance"
    ],
    "reliability": [
      "Zero data loss during operations",
      "Graceful handling of all error conditions",
      "Proper resource cleanup on exit",
      "Stable across system restarts"
    ],
    "usability": [
      "Intuitive command structure",
      "Clear error messages with guidance",
      "Consistent output formatting",
      "Seamless transition between modes"
    ]
  }
}